
/*
Struct

function copyBytesArray(mPtr, cdPtr) -> is_invalid, tail_offset {
  let arr_len := calldataload(cdPtr)
  mstore(mPtr, arr_len)
  mPtr := add(mPtr, 32)
  cdPtr := add(cdPtr, 32)
  tail_offset := mul(arr_len, 32)
  let arr_end := add(cdPtr, tail_offset)
  for {} lt(cdPtr, arr_end) {
    cdPtr := add(cdPtr, 32)
    mPtr := add(mPtr, 32)
  } {
    mstore(mPtr, add(mPtr, tail_offset))
    is_invalid := or(is_invalid, xor(calldataload(cdPtr), tail_offset)
    let bytesLength := roundUpAndAdd32(calldataload(add(cdPtr, tail_offset)))
    tail_offset := add(tail_offset, bytesLength)
  }
}

uint256 a;
bytes32 b;
uint256[] c;
bytes[] d;

let mPtr := mload(0x40)
let cdPtr := 4
let nextTailOffset = 0x80

mstore(add(mPtr, 0x40), add(mPtr, nextTailOffset))
let is_invalid := xor(calldataload(add(cdPtr, 0x40)), nextTailOffset)
let c_arr_len := mul(32, calldataload(add(cdPtr, nextTailOffset))
nextTailOffset := add(nextTailOffset, c_arr_len)

let d_tail_ptr := add(mPtr, nextTailOffset)
mstore(add(mPtr, 0x60), d_tail_ptr)
is_invalid := or(
  is_invalid,
  xor(calldataload(add(cdPtr, 0x60)), nextTailOffset)
)
let d_is_invalid, d_tail_offset := copyBytesArray(d_tail_ptr, add(cdPtr, nextTailOffset))

Array<uint256> {

}

Array<bytes> {
  function (dst, cdPtrParent, )
}

if ()

let x := 10
add(x, 10)

*/

/* function getArrayCopyCode(array: AbiArray) {
  if (array.baseType.meta === "elementary" || array.baseType.meta === "enum") {
    const handler = (mPtr: YulNode, cdPtr: YulNode) => {
      array.headOffset 
    }
  }
} */